# Even Realities G2 – development notes

## Overview

The G2 are smart glasses with dual micro-LED displays (one per lens), no camera, no speaker. Privacy-focused design. Paired with the R1 control ring for input. Connected to iPhone via BLE 5.x (~28m range).

## Architecture

Even Hub apps are **web apps** running inside a WebView in the Even App (Flutter, iPhone). There is no web server involved.

```
[Web App] <--WebView JS bridge--> [Even App (Flutter/iPhone)] <--BLE--> [G2 Glasses]
```

- The Even App hosts a `flutter_inappwebview`. When you launch an Even Hub app, it loads the web page inside this WebView.
- The SDK provides a JS bridge (`EvenAppBridge`) injected into `window`. Communication uses `flutter_inappwebview`'s `callHandler('evenAppMessage', ...)` – native WebView message passing, not HTTP.
- The Flutter app handles all BLE. Your web app never touches Bluetooth directly.

### Two-way communication

- **Web -> App:** JS calls `bridge.callEvenApp(method, params)` which sends a `call_even_app_method` message through the WebView bridge. The Flutter side executes it and returns the result.
- **App -> Web:** The Flutter side calls `window._listenEvenAppMessage(...)` to push events (device status, glasses UI events, audio PCM) into the WebView.

## Development flow

1. Build a web app (any framework) that imports `@evenrealities/even_hub_sdk`
2. During development, run locally – the Even App loads your localhost URL in its WebView
3. For production, deploy as a hosted web page – the Even App loads it from that URL

SDK: <https://www.npmjs.com/package/@evenrealities/even_hub_sdk>

```bash
npm install @evenrealities/even_hub_sdk
```

## G2 hardware

- Dual micro-LED displays, synced via physical FPC (not wireless)
- 576x288 pixel canvas per eye
- BLE 5.x – ~28m real-world range, ~9dB more power than G1
- Microphone (accessible via SDK)
- Touch gestures on temple tips
- R1 ring – separate BLE device for scroll/click input
- Wearing detection
- No camera, no speaker

## Display and UI system

### Canvas

576x288 pixels. Coordinate system: origin (0, 0) at top-left, X right, Y down. Greyscale display – colours map to grey levels (0–15 or 0–16 depending on container type).

### Container model

The UI is built from **containers** – rectangular regions positioned absolutely on the canvas. There is no CSS, no flexbox, no DOM. You define containers with pixel coordinates, and the glasses firmware renders them.

**Rules:**
- Max **4 containers per page** (mixed types allowed)
- Exactly **one** container must have `isEventCapture: 1` – this is the container that receives input events
- Container count is set via `containerTotalNum` and must match the actual number of containers passed
- Containers can overlap (later containers draw on top)
- No z-index control beyond declaration order

### Shared container properties

All container types share these layout properties:

| Property | Type | Range | Notes |
|---|---|---|---|
| `xPosition` | number | 0–576 | Left edge in pixels |
| `yPosition` | number | 0–288 | Top edge in pixels |
| `width` | number | 0–576 (list/text), 20–200 (image) | |
| `height` | number | 0–288 (list/text), 20–100 (image) | |
| `containerID` | number | any | Unique per page, used for updates |
| `containerName` | string | max 16 chars | Unique per page, used for updates |
| `isEventCapture` | number | 0 or 1 | Exactly one container must be 1 |

### Border and decoration

Available on list and text containers (not images):

| Property | Type | Range | Notes |
|---|---|---|---|
| `borderWidth` | number | 0–5 | 0 = no border |
| `borderColor` | number | 0–15 (list), 0–16 (text) | Greyscale level. Practical values: 5 is a subtle grey, 13 is brighter |
| `borderRdaius` | number | 0–10 | Rounded corners. Note: SDK uses `borderRdaius` (typo in protobuf, preserved in SDK) |
| `paddingLength` | number | 0–32 | Uniform padding on all sides |

No background colour property. No fill colour. The only visual decoration is the border.

### Text containers (`TextContainerProperty`)

The workhorse container. Renders plain text, left-aligned, top-aligned. No text alignment options (no centre, no right-align). No font size control. No bold/italic/underline.

```typescript
new TextContainerProperty({
  xPosition: 0,
  yPosition: 0,
  width: 576,
  height: 288,
  borderWidth: 0,
  borderColor: 5,
  paddingLength: 4,
  containerID: 1,
  containerName: 'main-text',
  content: 'Hello from G2',
  isEventCapture: 1,
})
```

**Content limits:**
- `createStartUpPageContainer`: max **1000 characters**
- `textContainerUpgrade`: max **2000 characters**
- `rebuildPageContainer`: max **1000 characters** (same as startup)

**Text rendering behaviour:**
- Text wraps at container width, but there is no internal scrolling – text renders from the top and clips at the bottom
- To "scroll" text, you must paginate it yourself and call `rebuildPageContainer` to show the next page (full redraw)
- `\n` works for line breaks
- Unicode characters work (e.g. `▲`, `━`, `─`, arrows) – useful for progress bars and indicators
- Approximate capacity: ~400–500 characters fill a full-screen (576x288) text container, depending on character width
- No font selection, no font size – the firmware uses a single fixed-width-ish font
- To "centre" text, you must manually pad with spaces

**Partial updates via `textContainerUpgrade`:**
- Updates text content in-place without a full page rebuild
- Requires matching `containerID` and `containerName`
- Has `contentOffset` and `contentLength` for partial replacement within the string
- Returns `boolean` (success/failure)
- **Caveat:** On the simulator, this still causes a visual redraw. On real hardware, it's smoother but text still renders from the top – there is no scroll position to preserve.

```typescript
await bridge.textContainerUpgrade(new TextContainerUpgrade({
  containerID: 1,
  containerName: 'main-text',
  contentOffset: 0,
  contentLength: 100,  // length of content to replace
  content: 'Updated text here',
}))
```

### List containers (`ListContainerProperty`)

Native scrollable list widget rendered by the glasses firmware. The glasses handle scroll highlighting natively – you don't need to manually track selection for scroll events.

```typescript
new ListContainerProperty({
  xPosition: 0,
  yPosition: 0,
  width: 576,
  height: 288,
  borderWidth: 1,
  borderColor: 13,
  borderRdaius: 6,
  paddingLength: 5,
  containerID: 1,
  containerName: 'my-list',
  isEventCapture: 1,
  itemContainer: new ListItemContainerProperty({
    itemCount: 5,
    itemWidth: 560,
    isItemSelectBorderEn: 1,
    itemName: ['Item 1', 'Item 2', 'Item 3', 'Item 4', 'Item 5'],
  }),
})
```

**`ListItemContainerProperty` fields:**

| Property | Type | Range | Notes |
|---|---|---|---|
| `itemCount` | number | 1–20 | Must match `itemName.length` |
| `itemWidth` | number | pixels | Width of each item row. Usually `containerWidth - 2*padding` |
| `isItemSelectBorderEn` | number | 0 or 1 | Show selection highlight border on current item |
| `itemName` | string[] | max 64 chars each | The text label for each item |

**List behaviour:**
- Scroll events (SCROLL_TOP/SCROLL_BOTTOM) move the selection highlight natively on the device – no `rebuildPageContainer` needed for scrolling
- Click events report `currentSelectItemIndex` and `currentSelectItemName` via `listEvent`
- No custom styling per item (no per-item colours, icons, or secondary text)
- No item height control – the firmware calculates item height from `containerHeight / itemCount`
- Items are plain text only, single line per item
- Cannot update list items in-place – must `rebuildPageContainer` to change items
- No separator lines between items (border is around the whole list)

**Gotcha:** List containers take over scroll handling. If you have a list on screen, scroll events arrive as `listEvent` (not `textEvent`/`sysEvent`), and the device moves the selection highlight automatically. You only need to respond to click/double-click.

### Image containers (`ImageContainerProperty`)

The most constrained container type. Small, greyscale-only images.

```typescript
new ImageContainerProperty({
  xPosition: 200,
  yPosition: 100,
  width: 100,
  height: 50,
  containerID: 3,
  containerName: 'logo',
})
```

| Constraint | Value |
|---|---|
| Width | 20–200 px |
| Height | 20–100 px |
| Colour | Converted to 4-bit greyscale (`imageToGray4`) by the host |
| Data formats | `number[]`, `Uint8Array`, `ArrayBuffer`, or base64 string |
| Concurrent sends | **Not allowed** – queue image updates sequentially |
| Startup phase | Cannot send image data during `createStartUpPageContainer` – create an empty placeholder, then update via `updateImageRawData` |

**`ImageRawDataUpdate` fields:**
- `containerID` – must match the image container
- `containerName` – must match the image container
- `imageData` – raw pixel data as `number[]`, `Uint8Array`, `ArrayBuffer`, or base64 string

**Advanced fields** (in `ImageRawDataUpdateFields`, for fragmented transfers):
- `mapSessionId`, `mapTotalSize`, `compressMode`, `mapFragmentIndex`, `mapFragmentPacketSize`, `mapRawData`

**Practical advice:**
- Keep images simple – single-colour icons, logos
- Glasses memory is limited – avoid frequent image updates
- The host converts to 4-bit grey (16 levels) – detailed images lose quality

## Input events

### Event types (`OsEventTypeList`)

| Event | Value | Source |
|---|---|---|
| `CLICK_EVENT` | 0 | Ring tap, temple tap |
| `SCROLL_TOP_EVENT` | 1 | Ring scroll up, swipe forward |
| `SCROLL_BOTTOM_EVENT` | 2 | Ring scroll down, swipe back |
| `DOUBLE_CLICK_EVENT` | 3 | Ring double-tap, temple double-tap |
| `FOREGROUND_ENTER_EVENT` | 4 | App comes to foreground |
| `FOREGROUND_EXIT_EVENT` | 5 | App goes to background |
| `ABNORMAL_EXIT_EVENT` | 6 | Unexpected disconnect |

### Event delivery

Events arrive via `bridge.onEvenHubEvent(callback)`. The callback receives an `EvenHubEvent` object with one of these populated:

```typescript
type EvenHubEvent = {
  listEvent?: List_ItemEvent    // from list containers
  textEvent?: Text_ItemEvent    // from text containers
  sysEvent?: Sys_ItemEvent      // system-level events
  audioEvent?: AudioEventPayload // microphone PCM
  jsonData?: Record<string, any> // raw payload for debugging
}
```

**`List_ItemEvent` fields:**
- `containerID` – which list container
- `containerName` – which list container
- `currentSelectItemName` – text of the selected item
- `currentSelectItemIndex` – 0-based index of selected item
- `eventType` – `OsEventTypeList` value

**`Text_ItemEvent` fields:**
- `containerID`, `containerName`, `eventType`

**`Sys_ItemEvent` fields:**
- `eventType` only

### Event quirks (critical for real-world apps)

1. **`CLICK_EVENT = 0` becomes `undefined`:** The SDK's `fromJson` normalises `0` to `undefined` in many cases. Always check `eventType === OsEventTypeList.CLICK_EVENT || eventType === undefined` to catch clicks.

2. **Missing `currentSelectItemIndex`:** The simulator (and sometimes real hardware) omits `currentSelectItemIndex` for the first list item (index 0). Fall back to tracking `selectedIndex` in your app state.

3. **Event routing depends on `isEventCapture`:** The container with `isEventCapture: 1` determines whether you get `listEvent` vs `textEvent`. If a list has capture, scrolls come as `listEvent`. If text has capture, scrolls come as `textEvent`.

4. **Simulator vs real device:** The simulator sends `sysEvent` for button clicks, while real hardware sends `textEvent` or `listEvent` depending on the active container. Handle all three event sources.

5. **Swipe throttling:** Scroll events can fire rapidly. Use a cooldown (e.g. 300ms) to prevent duplicate actions.

## Page lifecycle

### `createStartUpPageContainer`

Must be called **exactly once** at app startup. Establishes the initial page layout. Returns `StartUpPageCreateResult` (0=success, 1=invalid, 2=oversize, 3=outOfMemory).

```typescript
const result = await bridge.createStartUpPageContainer(
  new CreateStartUpPageContainer({
    containerTotalNum: 2,
    textObject: [textContainer],
    listObject: [listContainer],
  })
)
```

**Fields:** `containerTotalNum`, `listObject?`, `textObject?`, `imageObject?`

### `rebuildPageContainer`

Replaces the entire page. Can change container count, types, and layout. This is the primary way to navigate between screens.

```typescript
await bridge.rebuildPageContainer(
  new RebuildPageContainer({
    containerTotalNum: 1,
    textObject: [newTextContainer],
  })
)
```

**Behaviour:** Full redraw – all containers are destroyed and recreated. Any scroll position or selection state is lost. On real hardware this causes a brief flicker.

**Fields:** Same as `createStartUpPageContainer`.

### `textContainerUpgrade`

Updates text in an existing container without rebuilding the whole page. Faster and flicker-free (on real hardware).

```typescript
await bridge.textContainerUpgrade(new TextContainerUpgrade({
  containerID: 1,
  containerName: 'main-text',
  contentOffset: 0,
  contentLength: 50,
  content: 'New content',
}))
```

**Fields:** `containerID`, `containerName`, `contentOffset?`, `contentLength?`, `content`

### `updateImageRawData`

Updates image data for an existing image container.

```typescript
await bridge.updateImageRawData(new ImageRawDataUpdate({
  containerID: 3,
  containerName: 'logo',
  imageData: pixelBuffer,
}))
```

Returns `ImageRawDataUpdateResult` (success/imageException/imageSizeInvalid/imageToGray4Failed/sendFailed).

### `shutDownPageContainer`

Exits the app.

```typescript
await bridge.shutDownPageContainer(0) // 0 = immediate exit
await bridge.shutDownPageContainer(1) // 1 = show exit confirmation to user
```

## Audio

- `bridge.audioControl(true/false)` – open/close microphone
- Requires `createStartUpPageContainer` to be called first
- PCM data arrives via `onEvenHubEvent` as `audioEvent.audioPcm` (`Uint8Array`)
- PCM format: 16kHz sample rate, 10ms frame length (dtUs 10000), 40 bytes per frame, PCM S16LE (signed 16-bit little-endian), mono

## Device info

```typescript
const device = await bridge.getDeviceInfo()
// device.model – DeviceModel.G1 | DeviceModel.G2 | DeviceModel.Ring1
// device.sn – serial number (string)
// device.status.connectType – DeviceConnectType (none/connecting/connected/disconnected/connectionFailed)
// device.status.batteryLevel – 0-100
// device.status.isWearing – boolean
// device.status.isCharging – boolean
// device.status.isInCase – boolean
```

Real-time monitoring via `bridge.onDeviceStatusChanged(callback)`. Returns an unsubscribe function.

Helper methods on `DeviceInfo`: `isGlasses()`, `isRing()`.
Helper methods on `DeviceStatus`: `isConnected()`, `isConnecting()`, `isDisconnected()`, `isConnectionFailed()`, `isNone()`.

## User info

```typescript
const user = await bridge.getUserInfo()
// user.uid – number
// user.name – string
// user.avatar – string (URL)
// user.country – string
```

## Local storage

Key-value storage persisted on the phone side:

```typescript
await bridge.setLocalStorage('key', 'value') // returns boolean
const value = await bridge.getLocalStorage('key') // returns string
```

## What the SDK does NOT expose

- No direct BLE access
- No arbitrary pixel drawing – limited to list/text/image container model
- No `imgEvent` (defined in protocol but not in SDK types)
- No audio output (no speaker on hardware)
- No text alignment (no centre, right-align)
- No font size, weight, or family control
- No background colour or fill on containers
- No per-item styling in lists
- No internal scrolling in text containers
- No animations or transitions
- Image containers are heavily constrained (max 200x100, greyscale only)

## Error codes

### Page creation (`StartUpPageCreateResult`)

| Code | Meaning |
|---|---|
| 0 | Success |
| 1 | Invalid container configuration |
| 2 | Oversize – data too large for BLE transfer |
| 3 | Out of memory on glasses |

### Page rebuild

Returns `boolean`. The SDK has `APP_REQUEST_REBUILD_PAGE_SUCCESS` and `APP_REQUEST_REBUILD_PAGE_FAILD` (sic) error codes internally.

### Text upgrade

Returns `boolean`. Internal codes: `APP_REQUEST_UPGRADE_TEXT_DATA_SUCCESS` / `APP_REQUEST_UPGRADE_TEXT_DATA_FAILED`.

### Image update (`ImageRawDataUpdateResult`)

| Code | Meaning |
|---|---|
| success | OK |
| imageException | Image processing error |
| imageSizeInvalid | Dimensions outside 20–200 x 20–100 |
| imageToGray4Failed | Greyscale conversion failed |
| sendFailed | BLE send failed |

### Shutdown

Returns `boolean`. Internal codes: `APP_REQUEST_UPGRADE_SHUTDOWN_SUCCESS` / `APP_REQUEST_UPGRADE_SHUTDOWN_FAILED`.

## SDK JSON compatibility

The SDK handles multiple key naming conventions from the host:
- camelCase: `containerID`
- PascalCase: `ContainerID`
- Proto-style: `Container_ID`

All are accepted via `pickLoose()` which normalises keys by removing underscores and lowercasing. You only need to use camelCase in your code – the SDK handles the rest.

## UI patterns from real apps

### Fake "buttons" with text cursor

Since there are no button widgets, apps simulate interactive items by appending action labels to text content and tracking a cursor position with `>` prefix:

```
> Return
  Delete note
```

Scroll moves the `>` between items. Click triggers the selected action. Updated via `textContainerUpgrade` to avoid full page flicker.

### Selection highlight with text borders

Without lists, selection can be shown by toggling `borderWidth` (0 = unselected, 1–3 = selected) on individual text containers, each representing a "row".

### Multi-slot text layout

Multiple text containers act as rows (e.g. 3 containers at `height: 96` each = 288px total). Each container shows one "item" with its own border state. This simulates a list without the native list widget's scroll-takeover.

### Progress bars with Unicode

Text containers can display Unicode progress bars:
```typescript
const filled = '━'.repeat(n)
const empty = '─'.repeat(total - n)
const bar = filled + empty
```

### Hidden capture containers

When you need to receive events but don't want a visible list, create a 1x1 pixel list container off-screen or at (0,0):

```typescript
new ListContainerProperty({
  containerID: 99,
  containerName: 'hidden-capture',
  xPosition: 0, yPosition: 0, width: 1, height: 1,
  isEventCapture: 1,
  itemContainer: new ListItemContainerProperty({
    itemCount: 1, itemWidth: 1, isItemSelectBorderEn: 0, itemName: [' '],
  }),
})
```

### Page flipping for long text

Text doesn't scroll – split into pages of ~400–500 chars at word boundaries. Track `pageIndex`, rebuild page on scroll. Show page indicator in header or footer container.
